{% extends 'core/base.html' %}

{% block title %}Create Insight - TM IntelliMind{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-12">
        <h2 class="mb-4">Create New Insight</h2>
        
        <div class="card shadow">
            <div class="card-body">
                <div class="row">
                    <!-- Workflow Content Area -->
                    <div class="col-lg-8 col-xl-9">
                        <form id="upload-form" enctype="multipart/form-data">
                            {% csrf_token %}
                    
                    <!-- Steps 1 & 2: Side-by-Side Layout -->
                    <div class="row g-4 mb-4">
                        <!-- Step 1: Model Selection -->
                        <div class="col-lg-6">
                            <div class="card h-100" id="model-selection-card">
                                <div class="card-header">
                                    <h5 class="mb-0">
                                        <i class="fas fa-cogs me-2" aria-hidden="true"></i>
                                        1. Select Transcription Model
                                    </h5>
                                </div>
                                <div class="card-body" id="model-selection" role="region" aria-labelledby="model-selection-title">
                                    <!-- Transcription Provider Selection -->
                                    <div class="mb-4">
                                        <label class="form-label">Transcription Provider <span class="text-danger">*</span></label>
                                        <div class="row g-2">
                                            <div class="col-sm-6">
                                                <div class="form-check">
                                                    <input class="form-check-input" type="radio" name="transcription_provider" id="provider-local" value="local" checked>
                                                    <label class="form-check-label" for="provider-local">
                                                        <i class="fas fa-server me-1"></i>
                                                        <strong>Local Models</strong><br>
                                                        <small class="text-muted">Private, no API costs</small>
                                                    </label>
                                                </div>
                                            </div>
                                            <div class="col-sm-6">
                                                <div class="form-check">
                                                    <input class="form-check-input" type="radio" name="transcription_provider" id="provider-api" value="api">
                                                    <label class="form-check-label" for="provider-api">
                                                        <i class="fas fa-cloud me-1"></i>
                                                        <strong>External API</strong><br>
                                                        <small class="text-muted">Latest models, usage costs</small>
                                                    </label>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Local Models Configuration -->
                                    <div id="local-models-config" class="mb-3">
                                        <label for="whisper-model" class="form-label">Whisper Model <span class="text-danger">*</span></label>
                                        <select class="form-select" id="whisper-model" name="whisper_model" aria-describedby="local-model-help" required>
                                            <option value="">Choose a transcription model...</option>
                                            <option value="tiny">Tiny - Fastest (1-2 min)</option>
                                            <option value="base">Base - Good balance (2-3 min)</option>
                                            <option value="small">Small - Better accuracy (3-5 min)</option>
                                            <option value="medium">Medium - High accuracy (5-8 min) ⭐ Thai</option>
                                            <option value="large">Large - Highest accuracy (8-15 min) ⭐ Thai</option>
                                        </select>
                                        <div id="local-model-help" class="form-text">
                                            <strong>Thai:</strong> Medium or Large recommended<br>
                                            <strong>English:</strong> Small or Medium sufficient
                                        </div>
                                    </div>

                                    <!-- External API Configuration -->
                                    <div id="api-config" class="mb-3" style="display: none;">
                                        <div class="mb-3">
                                            <label for="api-provider" class="form-label">API Provider <span class="text-danger">*</span></label>
                                            <select class="form-select" id="api-provider" name="api_provider" aria-describedby="api-provider-help">
                                                <option value="">Choose an API provider...</option>
                                                <option value="openai">OpenAI Whisper API</option>
                                                <option value="assemblyai">AssemblyAI</option>
                                                <option value="deepgram">Deepgram</option>
                                                <option value="custom">Custom API Endpoint</option>
                                            </select>
                                            <div id="api-provider-help" class="form-text">
                                                Select your preferred transcription API provider.
                                            </div>
                                        </div>

                                        <!-- API Model Selection -->
                                        <div class="mb-3" id="api-model-section" style="display: none;">
                                            <label for="api-model" class="form-label">Model</label>
                                            <select class="form-select" id="api-model" name="api_model">
                                                <!-- Options will be populated based on provider selection -->
                                            </select>
                                        </div>

                                        <!-- Custom API Endpoint -->
                                        <div class="mb-3" id="custom-endpoint-section" style="display: none;">
                                            <label for="custom-endpoint" class="form-label">API Endpoint URL <span class="text-danger">*</span></label>
                                            <input type="url" class="form-control" id="custom-endpoint" name="custom_endpoint" 
                                                   placeholder="https://api.example.com/v1/transcribe" aria-describedby="custom-endpoint-help">
                                            <div id="custom-endpoint-help" class="form-text">
                                                Enter the full URL for your custom transcription API endpoint.
                                            </div>
                                        </div>

                                        <!-- API Key -->
                                        <div class="mb-3" id="api-key-section" style="display: none;">
                                            <label for="api-key" class="form-label">API Key <span class="text-danger">*</span></label>
                                            <input type="password" class="form-control" id="api-key" name="api_key" 
                                                   placeholder="Enter your API key" aria-describedby="api-key-help">
                                            <div id="api-key-help" class="form-text">
                                                Your API key will be encrypted and stored securely. <a href="#" id="show-api-key">Show</a>
                                            </div>
                                        </div>

                                        <!-- API Provider Info -->
                                        <div class="alert alert-info" role="alert" id="api-provider-info" style="display: none;">
                                            <div id="provider-info-content">
                                                <!-- Content will be populated based on provider selection -->
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div class="alert alert-info" role="alert" id="model-selection-info">
                                        <i class="fas fa-magic me-1" aria-hidden="true"></i>
                                        <strong>Progressive Transcription:</strong> For large files (>100MB), transcription will start automatically as chunks are processed. Small files will need manual transcription start.
                                    </div>
                                    
                                    <div class="d-grid gap-2">
                                        <button type="button" class="btn btn-primary" id="start-transcription" 
                                                aria-describedby="transcription-info" disabled style="display: none;">
                                            <i class="fas fa-play me-1" aria-hidden="true"></i>
                                            Start Transcription
                                        </button>
                                        <button type="button" class="btn btn-outline-secondary btn-sm" id="reset-upload" style="display: none;">
                                            <i class="fas fa-redo me-1" aria-hidden="true"></i>
                                            Upload New File
                                        </button>
                                    </div>
                                    <div id="transcription-info" class="form-text mt-2">
                                        Select a transcription model above, then upload your audio file.
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Step 2: Audio Upload Section -->
                        <div class="col-lg-6">
                            <div class="card h-100">
                                <div class="card-header">
                                    <h5 class="mb-0">
                                        <i class="fas fa-upload me-2" aria-hidden="true"></i>
                                        2. Upload Audio File
                                    </h5>
                                </div>
                                <div class="card-body">
                                    <!-- Language Selection -->
                                    <div class="mb-3">
                                        <label for="language-select" class="form-label">Audio Language</label>
                                        <select class="form-select" id="language-select" name="language" aria-describedby="language-help">
                                            <option value="auto">Auto-detect</option>
                                            <option value="th">Thai (ไทย)</option>
                                            <option value="en">English</option>
                                        </select>
                                        <div id="language-help" class="form-text">
                                            Select the primary language of your audio.
                                        </div>
                                    </div>

                                    <div class="upload-area disabled" id="upload-area" role="button" tabindex="-1" 
                                         aria-label="Upload audio file - select a transcription model first"
                                         aria-describedby="upload-instructions">
                                        <i class="fas fa-cloud-upload-alt fa-2x mb-2" aria-hidden="true"></i>
                                        <p class="mb-1" id="upload-instructions">Select a transcription model first</p>
                                        <p class="text-muted small mb-0">MP3, WAV, M4A, MP4 (Max: 500MB)</p>
                                        <input type="file" id="audio-file" name="audio_file" accept=".mp3,.wav,.m4a,.mp4" 
                                               class="d-none" required aria-label="Choose audio file" disabled>
                                    </div>
                                    
                                    <!-- File Validation Messages -->
                                    <div id="file-validation" class="mt-2" style="display: none;">
                                        <div class="alert alert-danger" role="alert" id="file-error"></div>
                                    </div>
                                    
                                    <div id="file-info" class="mt-2" style="display: none;">
                                        <div class="alert alert-success" role="alert">
                                            <strong>Selected:</strong> <span id="file-name"></span>
                                            <span id="file-size" class="ms-2"></span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>



                    <!-- Transcript Text -->
                    <div class="mb-4" id="transcript-section" style="display: none;" role="region" aria-labelledby="transcript-title">
                        <h5 id="transcript-title">3. Review & Edit Transcript</h5>
                        <div class="mb-3">
                            <label for="transcript-text" class="form-label visually-hidden">Transcript text</label>
                            <textarea class="form-control" id="transcript-text" name="transcript_text" rows="10" 
                                      placeholder="Transcript will appear here..." aria-describedby="transcript-help"></textarea>
                            <div id="transcript-help" class="form-text">
                                Review and edit the transcript for accuracy before generating insights. 
                                Corrections here will improve the quality of the analysis.
                            </div>
                        </div>
                        <div class="d-flex gap-2">
                            <button type="button" class="btn btn-success" id="generate-insights" aria-describedby="insights-info">
                                <i class="fas fa-lightbulb me-1" aria-hidden="true"></i>
                                Generate Insights
                            </button>
                            <button type="button" class="btn btn-outline-primary" id="retranscribe" style="display: none;">
                                <i class="fas fa-redo me-1" aria-hidden="true"></i>
                                Re-transcribe
                            </button>
                        </div>
                        <div id="insights-info" class="form-text mt-2">
                            AI will analyze your transcript and organize insights into 9 categories for Thailand's insurance sector.
                        </div>
                    </div>


                    <!-- Insights Display -->
                    <div class="mb-4" id="insights-section" style="display: none;" role="region" aria-labelledby="insights-title">
                        <h5 id="insights-title">
                            <i class="fas fa-chart-line me-2" aria-hidden="true"></i>
                            4. Generated Insights
                        </h5>
                        <div class="row g-3">
                            <!-- Situation Analysis - Smaller Column -->
                            <div class="col-lg-4">
                                <div class="card h-100">
                                    <div class="card-header">
                                        <h6 class="mb-0">
                                            <i class="fas fa-sitemap me-2" aria-hidden="true"></i>
                                            Situation Analysis
                                        </h6>
                                    </div>
                                    <div class="card-body">
                                        <label for="situation-text" class="form-label visually-hidden">Situation analysis</label>
                                        <textarea class="form-control border-0" id="situation-text" name="situation" 
                                                  rows="18" placeholder="Situation analysis will appear here..." 
                                                  aria-describedby="situation-help" style="min-height: 400px; resize: vertical;"></textarea>
                                        <div id="situation-help" class="form-text mt-2">
                                            Context and summary of the meeting discussion.
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Key Insights - Larger Column -->
                            <div class="col-lg-8">
                                <div class="card h-100">
                                    <div class="card-header d-flex justify-content-between align-items-center">
                                        <h6 class="mb-0">
                                            <i class="fas fa-lightbulb me-2" aria-hidden="true"></i>
                                            Key Insights (9 Categories)
                                        </h6>
                                        <div class="btn-group btn-group-sm" role="group" aria-label="Insights view options">
                                            <button type="button" class="btn btn-outline-primary active" id="insights-view-text" title="Text view">
                                                <i class="fas fa-align-left" aria-hidden="true"></i>
                                            </button>
                                            <button type="button" class="btn btn-outline-primary" id="insights-view-categories" title="Category view">
                                                <i class="fas fa-list" aria-hidden="true"></i>
                                            </button>
                                        </div>
                                    </div>
                                    <div class="card-body">
                                        <!-- Text View -->
                                        <div id="insights-text-view">
                                            <label for="insights-text" class="form-label visually-hidden">Key insights</label>
                                            <textarea class="form-control border-0" id="insights-text" name="insights" 
                                                      rows="18" placeholder="Key insights will appear here..." 
                                                      aria-describedby="insights-help" style="min-height: 400px; resize: vertical;"></textarea>
                                        </div>
                                        
                                        <!-- Category View (Hidden by default) -->
                                        <div id="insights-category-view" style="display: none;">
                                            <div class="insights-categories">
                                                <div class="row g-2">
                                                    <div class="col-md-6">
                                                        <div class="category-section mb-3">
                                                            <h6 class="text-primary mb-1">📋 Tasks & Action Items</h6>
                                                            <div class="category-content bg-light p-2 rounded small" id="category-tasks"></div>
                                                        </div>
                                                        <div class="category-section mb-3">
                                                            <h6 class="text-success mb-1">✅ Decisions Made</h6>
                                                            <div class="category-content bg-light p-2 rounded small" id="category-decisions"></div>
                                                        </div>
                                                        <div class="category-section mb-3">
                                                            <h6 class="text-info mb-1">❓ Questions & Answers</h6>
                                                            <div class="category-content bg-light p-2 rounded small" id="category-qa"></div>
                                                        </div>
                                                        <div class="category-section mb-3">
                                                            <h6 class="text-warning mb-1">💡 Key Insights</h6>
                                                            <div class="category-content bg-light p-2 rounded small" id="category-insights"></div>
                                                        </div>
                                                        <div class="category-section mb-3">
                                                            <h6 class="text-danger mb-1">⏰ Deadlines</h6>
                                                            <div class="category-content bg-light p-2 rounded small" id="category-deadlines"></div>
                                                        </div>
                                                    </div>
                                                    <div class="col-md-6">
                                                        <div class="category-section mb-3">
                                                            <h6 class="text-secondary mb-1">👥 Meeting Participants</h6>
                                                            <div class="category-content bg-light p-2 rounded small" id="category-participants"></div>
                                                        </div>
                                                        <div class="category-section mb-3">
                                                            <h6 class="text-primary mb-1">🔄 Follow-up Actions</h6>
                                                            <div class="category-content bg-light p-2 rounded small" id="category-followup"></div>
                                                        </div>
                                                        <div class="category-section mb-3">
                                                            <h6 class="text-danger mb-1">⚠️ Risks Identified</h6>
                                                            <div class="category-content bg-light p-2 rounded small" id="category-risks"></div>
                                                        </div>
                                                        <div class="category-section mb-3">
                                                            <h6 class="text-info mb-1">📅 Meeting Agenda</h6>
                                                            <div class="category-content bg-light p-2 rounded small" id="category-agenda"></div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <div id="insights-help" class="form-text mt-2">
                                            <strong>9 Categories:</strong> Tasks, Decisions, Q&A, Key Insights, Deadlines, Participants, Follow-ups, Risks, Agenda
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="d-flex justify-content-between flex-wrap gap-2 mt-4">
                            <div class="d-flex gap-2">
                                <button type="button" class="btn btn-success" id="save-all" aria-describedby="save-info">
                                    <i class="fas fa-save me-1" aria-hidden="true"></i>
                                    Save Complete Analysis
                                </button>
                                <button type="button" class="btn btn-outline-primary" id="regenerate-insights" style="display: none;">
                                    <i class="fas fa-redo me-1" aria-hidden="true"></i>
                                    Regenerate Insights
                                </button>
                            </div>
                            <div class="d-flex gap-2">
                                <button type="button" class="btn btn-outline-secondary" id="export-word" disabled 
                                        title="Export feature coming soon">
                                    <i class="fas fa-file-word me-1" aria-hidden="true"></i>
                                    Export to Word
                                </button>
                                <button type="button" class="btn btn-outline-secondary" id="print-analysis">
                                    <i class="fas fa-print me-1" aria-hidden="true"></i>
                                    Print
                                </button>
                            </div>
                        </div>
                        <div id="save-info" class="form-text mt-2">
                            Your analysis will be saved and accessible from the home page. You can continue editing after saving.
                        </div>
                    </div>
                        </form>
                    </div>
                    
                    <!-- Status Panel Sidebar -->
                    <div class="col-lg-4 col-xl-3">
                        <!-- Mobile Toggle Button -->
                        <button class="btn btn-primary w-100 mb-2 d-lg-none" type="button" 
                                data-bs-toggle="collapse" data-bs-target="#status-panel-collapse" 
                                aria-expanded="false" aria-controls="status-panel-collapse" id="status-panel-toggle">
                            <i class="fas fa-tasks me-2" aria-hidden="true"></i>
                            Status Panel
                            <i class="fas fa-chevron-down ms-2" id="status-panel-icon" aria-hidden="true"></i>
                        </button>
                        
                        <div class="collapse d-lg-block" id="status-panel-collapse">
                            <div class="status-panel sticky-top" style="top: 1rem;">
            <div class="card shadow-sm">
                <div class="card-header bg-primary text-white">
                    <h6 class="mb-0">
                        <i class="fas fa-tasks me-2" aria-hidden="true"></i>
                        Status Panel
                    </h6>
                </div>
                <div class="card-body p-3">
                    <!-- Workflow Progress Indicator -->
                    <div class="workflow-progress mb-4">
                        <h6 class="text-muted mb-3">Workflow Progress</h6>
                        <div class="step-indicator">
                            <div class="step" id="step-1">
                                <div class="step-number">1</div>
                                <div class="step-label">Upload</div>
                            </div>
                            <div class="step" id="step-2">
                                <div class="step-number">2</div>
                                <div class="step-label">Transcribe</div>
                            </div>
                            <div class="step" id="step-3">
                                <div class="step-number">3</div>
                                <div class="step-label">Review</div>
                            </div>
                            <div class="step" id="step-4">
                                <div class="step-number">4</div>
                                <div class="step-label">Insights</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Current Status -->
                    <div class="current-status mb-4">
                        <h6 class="text-muted mb-2">Current Status</h6>
                        <div class="status-message" id="sidebar-status" role="status" aria-live="polite">
                            <i class="fas fa-info-circle me-2 text-info"></i>
                            Ready to begin
                        </div>
                    </div>
                    
                    <!-- File Information -->
                    <div class="file-info mb-4" id="sidebar-file-info" style="display: none;">
                        <h6 class="text-muted mb-2">File Information</h6>
                        <div class="file-details bg-light p-2 rounded">
                            <div class="file-name" id="sidebar-file-name"></div>
                            <div class="file-size text-muted small" id="sidebar-file-size"></div>
                        </div>
                    </div>
                    
                    <!-- Progress Bars -->
                    <div class="progress-section">
                        <!-- Upload Progress -->
                        <div class="progress-item mb-3" id="sidebar-upload-progress" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <span class="small text-muted">Upload Progress</span>
                                <span class="small text-muted" id="sidebar-upload-percentage">0%</span>
                            </div>
                            <div class="progress progress-sm">
                                <div class="progress-bar" id="sidebar-upload-bar" role="progressbar" 
                                     aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Chunking Progress -->
                        <div class="progress-item mb-3" id="sidebar-chunking-progress" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <span class="small text-muted">Creating Chunks</span>
                                <span class="small text-muted" id="sidebar-chunking-percentage">0%</span>
                            </div>
                            <div class="progress progress-sm">
                                <div class="progress-bar bg-info" id="sidebar-chunking-bar" role="progressbar" 
                                     aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Transcription Progress -->
                        <div class="progress-item mb-3" id="sidebar-transcription-progress" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <span class="small text-muted">Transcription Progress</span>
                                <span class="small text-muted" id="sidebar-transcription-percentage">0%</span>
                            </div>
                            <div class="progress progress-sm">
                                <div class="progress-bar" id="sidebar-transcription-bar" role="progressbar" 
                                     aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Enhanced: Detailed Chunk Status Grid -->
                        <div class="progress-item mb-3" id="sidebar-chunk-details" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <span class="small text-muted">Chunk Progress</span>
                                <span class="small text-muted" id="sidebar-chunk-summary">0/0</span>
                            </div>
                            
                            <!-- Chunk Status Grid -->
                            <div class="chunk-grid mb-2" id="chunk-status-grid">
                                <!-- Chunks will be dynamically added here -->
                            </div>
                            
                            <!-- Legend -->
                            <div class="chunk-legend small text-muted">
                                <div class="d-flex flex-wrap gap-2">
                                    <span><span class="chunk-status-dot pending"></span> Pending</span>
                                    <span><span class="chunk-status-dot processing"></span> Processing</span>
                                    <span><span class="chunk-status-dot completed"></span> Completed</span>
                                    <span><span class="chunk-status-dot failed"></span> Failed</span>
                                </div>
                            </div>
                            
                            <!-- Quality Indicator -->
                            <div class="quality-indicator mt-2" id="transcription-quality" style="display: none;">
                                <div class="d-flex justify-content-between align-items-center">
                                    <span class="small text-muted">Avg. Quality:</span>
                                    <span class="small" id="average-confidence">-</span>
                                </div>
                                <div class="progress progress-sm mt-1">
                                    <div class="progress-bar bg-success" id="quality-bar" role="progressbar" 
                                         aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%">
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Enhanced: Detailed Timing Information -->
                        <div class="progress-item mb-3" id="sidebar-timing-details" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <span class="small text-muted">Time Estimates</span>
                                <span class="small text-muted" id="sidebar-time-remaining">-</span>
                            </div>
                            
                            <!-- Current Phase Info -->
                            <div class="timing-phase mb-2" id="current-phase-info">
                                <div class="small text-muted mb-1" id="phase-description">Processing...</div>
                                <div class="timing-metrics small">
                                    <div class="d-flex justify-content-between">
                                        <span>Rate:</span>
                                        <span id="processing-rate">-</span>
                                    </div>
                                    <div class="d-flex justify-content-between">
                                        <span>Active:</span>
                                        <span id="active-workers">-</span>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Phase Progress Bars -->
                            <div class="phase-progress" id="phase-progress-bars">
                                <!-- Dynamically populated phase progress bars -->
                            </div>
                        </div>
                        
                        <!-- Insights Progress -->
                        <div class="progress-item mb-3" id="sidebar-insights-progress" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <span class="small text-muted">Analysis Progress</span>
                                <span class="small text-muted" id="sidebar-insights-percentage">0%</span>
                            </div>
                            <div class="progress progress-sm">
                                <div class="progress-bar" id="sidebar-insights-bar" role="progressbar" 
                                     aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="action-buttons" id="sidebar-actions">
                        <button type="button" class="btn btn-outline-danger btn-sm w-100" id="sidebar-cancel" 
                                style="display: none;" aria-label="Cancel current operation">
                            <i class="fas fa-stop me-1" aria-hidden="true"></i>
                            Cancel
                        </button>
                    </div>
                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* Disabled upload area styles */
.upload-area.disabled {
    background-color: #f8f9fa;
    border-color: #dee2e6;
    color: #6c757d;
    cursor: not-allowed;
    opacity: 0.65;
}

.upload-area.disabled:hover {
    background-color: #f8f9fa;
    border-color: #dee2e6;
}

.upload-area.disabled i {
    color: #6c757d;
}

/* Enhanced Progress: Chunk Status Grid Styles */
.chunk-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(16px, 1fr));
    gap: 2px;
    max-height: 80px;
    overflow-y: auto;
    padding: 4px;
    background-color: #f8f9fa;
    border-radius: 4px;
}

.chunk-item {
    width: 16px;
    height: 16px;
    border-radius: 3px;
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
    border: 1px solid transparent;
}

.chunk-item:hover {
    transform: scale(1.2);
    z-index: 10;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.chunk-item.pending {
    background-color: #e9ecef;
    border-color: #ced4da;
}

.chunk-item.processing {
    background-color: #ffeaa7;
    border-color: #fdcb6e;
    animation: pulse-yellow 1.5s infinite;
}

.chunk-item.completed {
    background-color: #00b894;
    border-color: #00a085;
}

.chunk-item.failed {
    background-color: #e17055;
    border-color: #d63031;
}

.chunk-item.high-quality {
    box-shadow: 0 0 0 1px #00b894;
}

.chunk-item.low-quality {
    box-shadow: 0 0 0 1px #ffeaa7;
}

/* Chunk Status Dots for Legend */
.chunk-status-dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 4px;
}

.chunk-status-dot.pending {
    background-color: #e9ecef;
    border: 1px solid #ced4da;
}

.chunk-status-dot.processing {
    background-color: #ffeaa7;
    border: 1px solid #fdcb6e;
    animation: pulse-yellow 1.5s infinite;
}

.chunk-status-dot.completed {
    background-color: #00b894;
}

.chunk-status-dot.failed {
    background-color: #e17055;
}

/* Animations */
@keyframes pulse-yellow {
    0% { opacity: 1; }
    50% { opacity: 0.6; }
    100% { opacity: 1; }
}

/* Tooltip for chunk details */
.chunk-tooltip {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #333;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    white-space: nowrap;
    z-index: 1000;
    display: none;
}

.chunk-item:hover .chunk-tooltip {
    display: block;
}

/* Quality indicator styles */
.quality-indicator .progress-sm {
    height: 4px;
}

.quality-indicator .progress-bar.bg-success {
    background-color: #00b894 !important;
}

.quality-indicator .progress-bar.bg-warning {
    background-color: #ffeaa7 !important;
}

.quality-indicator .progress-bar.bg-danger {
    background-color: #e17055 !important;
}

/* Enhanced Progress: Timing Details Styles */
.timing-phase {
    background-color: #f8f9fa;
    border-radius: 4px;
    padding: 6px 8px;
    border-left: 3px solid #007bff;
}

.timing-metrics {
    font-size: 0.75rem;
    color: #6c757d;
}

.phase-progress-item {
    margin-bottom: 6px;
}

.phase-progress-item .small {
    font-size: 0.7rem;
}

.phase-progress-item .progress {
    height: 3px;
    margin-top: 2px;
}

.phase-progress .progress-bar.phase-chunking {
    background-color: #17a2b8;
}

.phase-progress .progress-bar.phase-transcribing {
    background-color: #28a745;
}

.phase-progress .progress-bar.phase-completed {
    background-color: #6c757d;
}

/* Time display formatting */
.time-display {
    font-variant-numeric: tabular-nums;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
}
</style>

<script>
let currentMeetingId = null;
let transcriptionInterval = null;
let insightsInterval = null;
let chunkingInterval = null;

// Session state management
const SessionState = {
    save() {
        const state = {
            currentMeetingId,
            timestamp: Date.now(),
            language: document.getElementById('language-select').value,
            model: document.getElementById('whisper-model').value
        };
        localStorage.setItem('tm_intellimind_session', JSON.stringify(state));
    },
    
    load() {
        const saved = localStorage.getItem('tm_intellimind_session');
        if (saved) {
            const state = JSON.parse(saved);
            // Check if session is less than 1 hour old
            if (Date.now() - state.timestamp < 3600000) {
                currentMeetingId = state.currentMeetingId;
                document.getElementById('language-select').value = state.language || 'auto';
                document.getElementById('whisper-model').value = state.model || 'medium';
                return state;
            }
        }
        return null;
    },
    
    clear() {
        localStorage.removeItem('tm_intellimind_session');
        currentMeetingId = null;
    }
};

// Reset UI to fresh state (clear old data)
function resetUIToFreshState() {
    console.log('Resetting UI to fresh state');
    
    // Hide transcript section
    const transcriptSection = document.getElementById('transcript-section');
    if (transcriptSection) {
        transcriptSection.style.display = 'none';
    }
    
    // Clear transcript textarea
    const transcriptTextarea = document.getElementById('transcript-text');
    if (transcriptTextarea) {
        transcriptTextarea.value = '';
        transcriptTextarea.placeholder = 'Transcript will appear here...';
    }
    
    // Hide insights section
    const insightsSection = document.getElementById('insights-section');
    if (insightsSection) {
        insightsSection.style.display = 'none';
    }
    
    // Clear insights textareas
    const situationText = document.getElementById('situation-text');
    if (situationText) {
        situationText.value = '';
    }
    
    const insightsText = document.getElementById('insights-text');
    if (insightsText) {
        insightsText.value = '';
    }
    
    // Hide action buttons
    const resetButton = document.getElementById('reset-upload');
    if (resetButton) {
        resetButton.style.display = 'none';
    }
    
    const retranscribeButton = document.getElementById('retranscribe');
    if (retranscribeButton) {
        retranscribeButton.style.display = 'none';
    }
    
    const regenerateInsightsButton = document.getElementById('regenerate-insights');
    if (regenerateInsightsButton) {
        regenerateInsightsButton.style.display = 'none';
    }
    
    // Disable Generate Insights button
    const generateButton = document.getElementById('generate-insights');
    if (generateButton) {
        generateButton.disabled = true;
    }
    
    // Reset workflow steps
    updateWorkflowStep(1, 'active');
    updateWorkflowStep(2, 'pending');
    updateWorkflowStep(3, 'pending');
    updateWorkflowStep(4, 'pending');
    
    console.log('UI reset to fresh state completed');
}

// File validation
function validateFile(file) {
    const errors = [];
    const maxSize = 500 * 1024 * 1024; // 500MB
    const allowedTypes = ['audio/mp3', 'audio/wav', 'audio/m4a', 'video/mp4', 'audio/mpeg', 'audio/wave'];
    
    if (file.size > maxSize) {
        errors.push(`File size (${formatFileSize(file.size)}) exceeds the 500MB limit.`);
    }
    
    // Validate file type - require both MIME type and extension to match
    const hasValidMimeType = allowedTypes.includes(file.type);
    const hasValidExtension = file.name.toLowerCase().match(/\.(mp3|wav|m4a|mp4)$/);
    const isValidType = hasValidMimeType && hasValidExtension;
    
    if (!isValidType) {
        if (!hasValidMimeType && !hasValidExtension) {
            errors.push(`File type "${file.type || 'unknown'}" with extension "${file.name.split('.').pop()}" is not supported. Please use MP3, WAV, M4A, or MP4.`);
        } else if (!hasValidMimeType) {
            errors.push(`File MIME type "${file.type || 'unknown'}" is not supported. Please ensure you're uploading a valid audio file.`);
        } else if (!hasValidExtension) {
            errors.push(`File extension "${file.name.split('.').pop()}" is not supported. Please use MP3, WAV, M4A, or MP4.`);
        }
    }
    
    return errors;
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function showError(message, containerId = 'file-validation') {
    // Show error in sidebar as well
    updateSidebarStatus(message, 'error');
    
    const container = document.getElementById(containerId);
    if (container) {
        const errorDiv = document.getElementById('file-error');
        if (errorDiv) {
            errorDiv.textContent = message;
            container.style.display = 'block';
        }
    }
    
    // Announce to screen readers
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', 'assertive');
    announcement.setAttribute('aria-atomic', 'true');
    announcement.className = 'visually-hidden';
    announcement.textContent = `Error: ${message}`;
    document.body.appendChild(announcement);
    setTimeout(() => document.body.removeChild(announcement), 1000);
}

function hideError(containerId = 'file-validation') {
    document.getElementById(containerId).style.display = 'none';
}

// File upload handling with keyboard support
document.getElementById('upload-area').addEventListener('click', function() {
    document.getElementById('audio-file').click();
});

document.getElementById('upload-area').addEventListener('keydown', function(e) {
    if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        document.getElementById('audio-file').click();
    }
});

document.getElementById('audio-file').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
        const errors = validateFile(file);
        if (errors.length > 0) {
            showError(errors.join(' '));
            return;
        }
        
        hideError();
        document.getElementById('file-name').textContent = file.name;
        document.getElementById('file-size').textContent = `(${formatFileSize(file.size)})`;
        document.getElementById('file-info').style.display = 'block';
        uploadFile(file);
    }
});

// Drag and drop handling with improved accessibility
const uploadArea = document.getElementById('upload-area');
uploadArea.addEventListener('dragover', function(e) {
    e.preventDefault();
    uploadArea.classList.add('dragover');
    uploadArea.setAttribute('aria-label', 'Drop file here to upload');
});

uploadArea.addEventListener('dragleave', function(e) {
    e.preventDefault();
    if (!uploadArea.contains(e.relatedTarget)) {
        uploadArea.classList.remove('dragover');
        uploadArea.setAttribute('aria-label', 'Upload audio file by clicking or drag and drop');
    }
});

uploadArea.addEventListener('drop', function(e) {
    e.preventDefault();
    uploadArea.classList.remove('dragover');
    uploadArea.setAttribute('aria-label', 'Upload audio file by clicking or drag and drop');
    
    const file = e.dataTransfer.files[0];
    if (file) {
        const errors = validateFile(file);
        if (errors.length > 0) {
            showError(errors.join(' '));
            return;
        }
        
        hideError();
        document.getElementById('audio-file').files = e.dataTransfer.files;
        document.getElementById('file-name').textContent = file.name;
        document.getElementById('file-size').textContent = `(${formatFileSize(file.size)})`;
        document.getElementById('file-info').style.display = 'block';
        uploadFile(file);
    }
});

// Sidebar status and progress management
function updateSidebarStatus(message, type = 'info') {
    const statusElement = document.getElementById('sidebar-status');
    let icon = 'fas fa-info-circle text-info';
    
    switch(type) {
        case 'success':
            icon = 'fas fa-check-circle text-success';
            break;
        case 'error':
            icon = 'fas fa-exclamation-triangle text-danger';
            break;
        case 'warning':
            icon = 'fas fa-exclamation-circle text-warning';
            break;
        case 'processing':
            icon = 'fas fa-spinner fa-spin text-primary';
            break;
    }
    
    statusElement.innerHTML = `<i class="${icon} me-2"></i>${message}`;
}

function updateSidebarProgress(progressType, percentage, show = true) {
    const progressContainer = document.getElementById(`sidebar-${progressType}-progress`);
    const progressBar = document.getElementById(`sidebar-${progressType}-bar`);
    const percentageElement = document.getElementById(`sidebar-${progressType}-percentage`);
    
    // Add null check for progressContainer
    if (!progressContainer) {
        console.warn(`Progress container not found for type: ${progressType}`);
        return;
    }
    
    if (show) {
        progressContainer.style.display = 'block';
        progressContainer.classList.add('active');
    } else {
        progressContainer.style.display = 'none';
        progressContainer.classList.remove('active');
    }
    
    if (progressBar) {
        progressBar.style.width = percentage + '%';
        progressBar.setAttribute('aria-valuenow', percentage);
    }
    
    if (percentageElement) {
        percentageElement.textContent = percentage + '%';
    }
}

function updateWorkflowStep(stepNumber, status = 'active') {
    // Remove all statuses from all steps
    for (let i = 1; i <= 4; i++) {
        const step = document.getElementById(`step-${i}`);
        step.classList.remove('active', 'completed');
    }
    
    // Apply status to specific step and mark previous as completed
    for (let i = 1; i <= stepNumber; i++) {
        const step = document.getElementById(`step-${i}`);
        if (i < stepNumber) {
            step.classList.add('completed');
        } else if (i === stepNumber) {
            step.classList.add(status);
        }
    }
}

function showSidebarFileInfo(filename, size) {
    const fileInfoContainer = document.getElementById('sidebar-file-info');
    const filenameElement = document.getElementById('sidebar-file-name');
    const filesizeElement = document.getElementById('sidebar-file-size');
    
    filenameElement.textContent = filename;
    filesizeElement.textContent = size;
    fileInfoContainer.style.display = 'block';
}

function showSidebarCancel(show = true, action = null) {
    const cancelButton = document.getElementById('sidebar-cancel');
    
    if (show) {
        cancelButton.style.display = 'block';
        if (action) {
            cancelButton.onclick = action;
        }
    } else {
        cancelButton.style.display = 'none';
        cancelButton.onclick = null;
    }
}

// Upload file function with sidebar integration
function uploadFile(file) {
    // Get transcription configuration
    const provider = document.querySelector('input[name="transcription_provider"]:checked').value;
    const formData = new FormData();
    formData.append('audio_file', file);
    formData.append('transcription_provider', provider);
    formData.append('csrfmiddlewaretoken', getCSRFToken());

    if (provider === 'local') {
        const selectedModel = document.getElementById('whisper-model').value;
        if (!selectedModel) {
            updateSidebarStatus('Please select a transcription model first', 'warning');
            return;
        }
        formData.append('transcription_model', selectedModel);
    } else if (provider === 'api') {
        const apiProvider = document.getElementById('api-provider').value;
        const apiKey = document.getElementById('api-key').value.trim();
        
        if (!apiProvider) {
            updateSidebarStatus('Please select an API provider first', 'warning');
            return;
        }
        
        if (!apiKey) {
            updateSidebarStatus('Please enter your API key', 'warning');
            return;
        }
        
        formData.append('api_provider', apiProvider);
        formData.append('api_key', apiKey);
        
        if (apiProvider === 'custom') {
            const customEndpoint = document.getElementById('custom-endpoint').value.trim();
            if (!customEndpoint) {
                updateSidebarStatus('Please enter the custom API endpoint URL', 'warning');
                return;
            }
            formData.append('custom_endpoint', customEndpoint);
        } else {
            const apiModel = document.getElementById('api-model').value;
            if (!apiModel) {
                updateSidebarStatus('Please select an API model', 'warning');
                return;
            }
            formData.append('api_model', apiModel);
        }
    }

    // Update sidebar status
    updateWorkflowStep(1, 'active');
    updateSidebarStatus('Starting upload...', 'processing');
    updateSidebarProgress('upload', 0, true);
    showSidebarFileInfo(file.name, formatFileSize(file.size));
    
    // Simulate upload progress
    let simulatedProgress = 0;
    const uploadSimulation = setInterval(() => {
        simulatedProgress += Math.random() * 20;
        if (simulatedProgress < 90) {
            updateSidebarProgress('upload', Math.floor(simulatedProgress));
        }
    }, 200);
    
    fetch('{% url "core:upload_audio" %}', {
        method: 'POST',
        body: formData
    })
    .then(response => {
        clearInterval(uploadSimulation);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json().catch(error => {
            throw new Error('Invalid JSON response from server');
        });
    })
    .then(data => {
        if (data.success) {
            currentMeetingId = data.meeting_id;
            SessionState.save();
            updateSidebarProgress('upload', 100);
            
            // Check if file requires chunking and progressive transcription
            if (data.is_large_file && data.chunking_info && data.progressive_transcription) {
                const chunkInfo = data.chunking_info;
                const progressiveInfo = data.progressive_transcription;
                
                updateSidebarStatus('Large file detected! Starting progressive transcription...', 'processing');
                
                // Show detailed progressive transcription information
                let infoText = `🎯 Progressive Transcription Started!\n`;
                infoText += `📁 File: ${chunkInfo.file_size_mb} MB with ${chunkInfo.estimated_chunks} chunks\n`;
                infoText += `🤖 Model: ${progressiveInfo.model}\n`;
                infoText += `⚡ Transcription will begin automatically as chunks are ready\n`;
                infoText += `⏱️ Estimated processing: ${Math.ceil(chunkInfo.estimated_time_seconds / 60)} minutes\n`;
                infoText += `\n${progressiveInfo.message}`;
                document.getElementById('transcription-info').textContent = infoText;
                
                // No need for manual transcription start - it's automatic
                document.getElementById('start-transcription').style.display = 'none';
                
                // Start polling for chunking progress (which now includes transcription)
                setTimeout(() => {
                    pollChunkingProgress();
                }, 1000); // Start polling after 1 second
                
                // Show progressive transcript section immediately
                document.getElementById('transcript-section').style.display = 'block';
                document.getElementById('transcript-text').placeholder = 'Progressive transcript will appear here as chunks are processed...';
                
            } else if (data.is_large_file) {
                // Fallback for large files without full progressive info
                updateSidebarStatus('Upload completed! Large file detected - processing chunks...', 'processing');
                
                // Always show transcript section for large files (fallback)
                document.getElementById('transcript-section').style.display = 'block';
                document.getElementById('transcript-text').placeholder = 'Progressive transcript will appear here...';
                document.getElementById('transcription-info').textContent = 'Large file detected. Progressive transcription will start automatically.';
                document.getElementById('start-transcription').style.display = 'none';
                pollChunkingProgress();
                
            } else {
                updateSidebarStatus('Upload completed successfully!', 'success');
                document.getElementById('transcription-info').textContent = 'Small file uploaded. Click "Start Transcription" to begin processing.';
                // Enable transcription button for normal files
                document.getElementById('start-transcription').disabled = false;
                document.getElementById('start-transcription').style.display = 'inline-block';
            }
            
            updateWorkflowStep(1, 'completed');
            
            // Update UI (transcription button enabling is handled above based on file type)
            document.getElementById('reset-upload').style.display = 'inline-block';
            
            // Hide upload progress after a delay
            setTimeout(() => {
                updateSidebarProgress('upload', 100, false);
            }, 2000);
            
            // Focus management
            setTimeout(() => {
                document.getElementById('start-transcription').focus();
            }, 500);
        } else {
            throw new Error(data.error || 'Upload failed');
        }
    })
    .catch(error => {
        clearInterval(uploadSimulation);
        updateSidebarProgress('upload', 0, false);
        updateSidebarStatus(`Upload failed: ${error.message}. Click to retry.`, 'error');
        showError(`Upload failed: ${error.message}`);
        
        // Add retry functionality to sidebar status
        const statusElement = document.getElementById('sidebar-status');
        statusElement.style.cursor = 'pointer';
        statusElement.onclick = () => {
            statusElement.style.cursor = 'default';
            statusElement.onclick = null;
            uploadFile(file);
        };
    });
}

// Start transcription with sidebar integration
document.getElementById('start-transcription').addEventListener('click', function() {
    if (!currentMeetingId) return;
    
    const model = document.getElementById('whisper-model').value;
    const language = document.getElementById('language-select').value;
    
    // Update sidebar status
    updateWorkflowStep(2, 'active');
    updateSidebarStatus('Starting transcription...', 'processing');
    updateSidebarProgress('transcription', 0, true);
    showSidebarCancel(true, cancelTranscription);
    
    fetch('{% url "core:start_transcription" %}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken()
        },
        body: JSON.stringify({
            meeting_id: currentMeetingId,
            whisper_model: model,
            language: language !== 'auto' ? language : null
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json().catch(error => {
            throw new Error('Invalid JSON response from server');
        });
    })
    .then(data => {
        if (data.success) {
            SessionState.save();
            pollTranscriptionProgress();
        } else {
            throw new Error(data.error || 'Transcription failed to start');
        }
    })
    .catch(error => {
        updateSidebarProgress('transcription', 0, false);
        updateSidebarStatus(`Error: ${error.message}`, 'error');
        showSidebarCancel(false);
    });
});

// Enhanced Progress: Chunk Status Grid Management
function updateChunkStatusGrid(chunksInfo) {
    const chunkGrid = document.getElementById('chunk-status-grid');
    const chunkSummary = document.getElementById('sidebar-chunk-summary');
    const chunkDetails = document.getElementById('sidebar-chunk-details');
    
    if (!chunksInfo || !chunksInfo.details || chunksInfo.details.length === 0) {
        chunkDetails.style.display = 'none';
        return;
    }
    
    // Show the chunk details section
    chunkDetails.style.display = 'block';
    
    // Update summary
    const total = chunksInfo.total || chunksInfo.details.length;
    const completed = chunksInfo.completed || 0;
    chunkSummary.textContent = `${completed}/${total}`;
    
    // Clear existing chunks
    chunkGrid.innerHTML = '';
    
    // Add chunk items
    chunksInfo.details.forEach(chunk => {
        const chunkItem = document.createElement('div');
        chunkItem.className = `chunk-item ${chunk.status}`;
        chunkItem.setAttribute('data-chunk-index', chunk.index);
        
        // Add quality indicator if confidence score available
        if (chunk.confidence_score !== undefined) {
            if (chunk.confidence_score >= 0.8) {
                chunkItem.classList.add('high-quality');
            } else if (chunk.confidence_score < 0.6) {
                chunkItem.classList.add('low-quality');
            }
        }
        
        // Create tooltip with chunk details
        const tooltip = document.createElement('div');
        tooltip.className = 'chunk-tooltip';
        
        let tooltipText = `Chunk ${chunk.index}: ${chunk.status}`;
        if (chunk.start_time !== undefined && chunk.end_time !== undefined) {
            tooltipText += `\\n${chunk.start_time.toFixed(1)}s - ${chunk.end_time.toFixed(1)}s`;
        }
        if (chunk.transcript_length > 0) {
            tooltipText += `\\n${chunk.transcript_length} chars`;
        }
        if (chunk.confidence_score !== undefined) {
            tooltipText += `\\nQuality: ${(chunk.confidence_score * 100).toFixed(0)}%`;
        }
        if (chunk.error_message) {
            tooltipText += `\\nError: ${chunk.error_message}`;
        }
        
        tooltip.textContent = tooltipText;
        chunkItem.appendChild(tooltip);
        
        // Add click handler for failed chunks (future retry functionality)
        if (chunk.status === 'failed') {
            chunkItem.style.cursor = 'pointer';
            chunkItem.title = 'Click to retry (coming soon)';
        }
        
        chunkGrid.appendChild(chunkItem);
    });
}

function updateTranscriptionQuality(chunksInfo) {
    const qualityIndicator = document.getElementById('transcription-quality');
    const qualityBar = document.getElementById('quality-bar');
    const averageConfidence = document.getElementById('average-confidence');
    
    if (!chunksInfo || !chunksInfo.details) {
        qualityIndicator.style.display = 'none';
        return;
    }
    
    // Calculate average confidence score
    const chunksWithScores = chunksInfo.details.filter(chunk => 
        chunk.confidence_score !== undefined && chunk.status === 'completed'
    );
    
    if (chunksWithScores.length === 0) {
        qualityIndicator.style.display = 'none';
        return;
    }
    
    const avgScore = chunksWithScores.reduce((sum, chunk) => 
        sum + chunk.confidence_score, 0) / chunksWithScores.length;
    
    // Show quality indicator
    qualityIndicator.style.display = 'block';
    
    // Update display
    const percentage = Math.round(avgScore * 100);
    averageConfidence.textContent = `${percentage}%`;
    qualityBar.style.width = `${percentage}%`;
    
    // Set color based on quality
    qualityBar.className = 'progress-bar';
    if (avgScore >= 0.8) {
        qualityBar.classList.add('bg-success');
    } else if (avgScore >= 0.6) {
        qualityBar.classList.add('bg-warning');
    } else {
        qualityBar.classList.add('bg-danger');
    }
}

function updateTimingDetails(timingInfo, status, transcriptionInfo) {
    const timingDetails = document.getElementById('sidebar-timing-details');
    const timeRemaining = document.getElementById('sidebar-time-remaining');
    const phaseDescription = document.getElementById('phase-description');
    const processingRate = document.getElementById('processing-rate');
    const activeWorkers = document.getElementById('active-workers');
    const phaseProgressBars = document.getElementById('phase-progress-bars');
    
    if (!timingInfo || !timingInfo.time_remaining) {
        timingDetails.style.display = 'none';
        return;
    }
    
    // Show timing details section
    timingDetails.style.display = 'block';
    
    // Format time remaining
    const formatTime = (seconds) => {
        if (seconds < 60) return `${seconds}s`;
        if (seconds < 3600) return `${Math.ceil(seconds / 60)}m`;
        return `${Math.ceil(seconds / 3600)}h ${Math.ceil((seconds % 3600) / 60)}m`;
    };
    
    timeRemaining.textContent = formatTime(timingInfo.time_remaining);
    timeRemaining.className = 'small text-muted time-display';
    
    // Update phase-specific information
    const phaseEstimates = timingInfo.phase_estimates || {};
    
    switch (status) {
        case 'chunking':
            phaseDescription.textContent = 'Creating audio chunks...';
            processingRate.textContent = `${phaseEstimates.chunks_per_second || 0.5}/s`;
            activeWorkers.textContent = '1 chunker';
            break;
            
        case 'transcription_starting':
            phaseDescription.textContent = 'Starting transcription...';
            processingRate.textContent = `${phaseEstimates.concurrent_limit || 3} max`;
            activeWorkers.textContent = 'Initializing';
            break;
            
        case 'transcribing':
            phaseDescription.textContent = 'Transcribing chunks...';
            const rate = phaseEstimates.estimated_rate_per_chunk || 30;
            processingRate.textContent = `${rate}s/chunk`;
            activeWorkers.textContent = `${phaseEstimates.active_transcriptions || 0}/${phaseEstimates.concurrent_factor || 3}`;
            break;
            
        case 'completed':
            phaseDescription.textContent = 'Processing complete!';
            processingRate.textContent = 'Finished';
            activeWorkers.textContent = 'None';
            break;
            
        default:
            phaseDescription.textContent = 'Processing...';
            processingRate.textContent = '-';
            activeWorkers.textContent = '-';
    }
    
    // Create phase progress visualization
    phaseProgressBars.innerHTML = '';
    
    if (phaseEstimates.chunking_remaining !== undefined) {
        // Chunking phase bar
        const chunkingItem = createPhaseProgressBar(
            'Chunking', 
            phaseEstimates.chunking_remaining,
            phaseEstimates.chunking_remaining + (phaseEstimates.transcription_upcoming || 0),
            'phase-chunking'
        );
        phaseProgressBars.appendChild(chunkingItem);
    }
    
    if (phaseEstimates.transcription_remaining !== undefined || phaseEstimates.transcription_upcoming !== undefined) {
        // Transcription phase bar
        const transcriptionTime = phaseEstimates.transcription_remaining || phaseEstimates.transcription_upcoming || 0;
        const transcriptionItem = createPhaseProgressBar(
            'Transcription',
            transcriptionTime,
            timingInfo.total_estimated_time || transcriptionTime,
            'phase-transcribing'
        );
        phaseProgressBars.appendChild(transcriptionItem);
    }
}

function createPhaseProgressBar(label, remaining, total, cssClass) {
    const item = document.createElement('div');
    item.className = 'phase-progress-item';
    
    const progress = Math.max(0, Math.min(100, ((total - remaining) / total) * 100));
    
    item.innerHTML = `
        <div class="d-flex justify-content-between align-items-center">
            <span class="small text-muted">${label}</span>
            <span class="small text-muted time-display">${formatTimeShort(remaining)}</span>
        </div>
        <div class="progress">
            <div class="progress-bar ${cssClass}" 
                 style="width: ${progress}%"
                 role="progressbar" 
                 aria-valuenow="${progress}" 
                 aria-valuemin="0" 
                 aria-valuemax="100">
            </div>
        </div>
    `;
    
    return item;
}

function formatTimeShort(seconds) {
    if (seconds < 60) return `${Math.ceil(seconds)}s`;
    if (seconds < 3600) return `${Math.ceil(seconds / 60)}m`;
    return `${Math.ceil(seconds / 3600)}h`;
}

// Enhanced polling with sidebar integration
function pollTranscriptionProgress(retryCount = 0) {
    const maxRetries = 3;
    const baseDelay = 2000;
    const delay = Math.min(baseDelay * Math.pow(1.5, retryCount), 10000);
    
    transcriptionInterval = setTimeout(() => {
        fetch(`{% url "core:transcription_progress" %}?meeting_id=${currentMeetingId}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json().catch(error => {
            throw new Error('Invalid JSON response from server');
        });
        })
        .then(data => {
            if (data.success === false) {
                throw new Error(data.error || 'Transcription progress check failed');
            }
            updateSidebarProgress('transcription', data.progress || 0);
            
            // Enhanced status for chunked files
            if (data.is_chunked && data.chunks_info) {
                const chunksInfo = data.chunks_info;
                const statusText = `Processing chunks: ${chunksInfo.completed}/${chunksInfo.total} completed`;
                updateSidebarStatus(statusText, 'processing');
            } else {
                updateSidebarStatus(data.status || 'Processing...', 'processing');
            }
            
            if (data.status === 'completed') {
                document.getElementById('transcript-text').value = data.transcript || data.text || '';
                document.getElementById('transcript-section').style.display = 'block';
                document.getElementById('retranscribe').style.display = 'inline-block';
                
                // Update sidebar
                updateSidebarProgress('transcription', 100, false);
                updateSidebarStatus('Transcription completed successfully!', 'success');
                updateWorkflowStep(2, 'completed');
                updateWorkflowStep(3, 'active');
                showSidebarCancel(false);
                
                // Focus management
                setTimeout(() => {
                    document.getElementById('transcript-text').focus();
                }, 500);
                
            } else if (data.status === 'failed') {
                updateSidebarProgress('transcription', 0, false);
                updateSidebarStatus(`Transcription failed: ${data.error || 'Unknown error'}`, 'error');
                showSidebarCancel(false);
                
            } else {
                // Continue polling with reset retry count on success
                pollTranscriptionProgress(0);
            }
        })
        .catch(error => {
            if (retryCount < maxRetries) {
                console.warn(`Polling attempt ${retryCount + 1} failed, retrying...`, error);
                pollTranscriptionProgress(retryCount + 1);
            } else {
                updateSidebarProgress('transcription', 0, false);
                updateSidebarStatus('Connection error. Please check your internet connection.', 'error');
                showSidebarCancel(false);
            }
        });
    }, delay);
}

// Removed - retry functionality now handled via sidebar status messages

// Poll chunking and transcription progress for large files (unified)
function pollChunkingProgress() {
    if (!currentMeetingId) return;
    
    let pollCount = 0;
    let chunkingStuckCount = 0;
    const maxPolls = 1800; // 1 hour max (1800 * 2 seconds)
    const maxChunkingStuck = 15; // 30 seconds stuck on chunking (15 * 2 seconds)
    let lastChunkingStatus = null;
    
    chunkingInterval = setInterval(() => {
        pollCount++;
        
        // Safety check: stop polling after max attempts
        if (pollCount >= maxPolls) {
            console.warn('Progress polling stopped: maximum time limit reached');
            clearInterval(chunkingInterval);
            chunkingInterval = null;
            updateSidebarStatus('Processing taking longer than expected. Please refresh if needed.', 'warning');
            return;
        }
        // Stop polling if tab is not visible (reduces unnecessary requests)
        if (document.hidden) {
            console.log('Polling paused: tab not visible');
            return;
        }
        
        fetch(`{% url "core:chunking_progress" %}?meeting_id=${currentMeetingId}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success === false) {
                throw new Error(data.error || 'Progress check failed');
            }
            
            const chunksInfo = data.chunks_info;
            const transcriptionInfo = data.transcription_info;
            const fileInfo = data.file_info;
            
            // Check for stuck chunking status
            if (data.status === 'chunking') {
                const currentStatus = `${chunksInfo.total}/${chunksInfo.estimated_total}`;
                if (lastChunkingStatus === currentStatus) {
                    chunkingStuckCount++;
                    if (chunkingStuckCount >= maxChunkingStuck) {
                        console.warn('Chunking appears stuck, forcing progression to transcription');
                        // Force transition to transcription status
                        data.status = 'transcription_starting';
                        data.status_message = `Chunks ready: ${chunksInfo.total} chunks created`;
                        data.progress = 45;
                        chunkingStuckCount = 0; // Reset counter
                    }
                } else {
                    chunkingStuckCount = 0; // Reset if progress changed
                }
                lastChunkingStatus = currentStatus;
            } else {
                chunkingStuckCount = 0; // Reset on non-chunking status
                lastChunkingStatus = null;
            }
            
            // Use the enhanced status message from the backend
            updateSidebarStatus(data.status_message, 'processing');
            updateSidebarProgress('chunking', data.progress, true);
            
            // Enhanced Progress: Update chunk status grid and quality indicators
            updateChunkStatusGrid(chunksInfo);
            updateTranscriptionQuality(chunksInfo);
            
            // Enhanced Progress: Update detailed timing information
            if (data.timing_info) {
                updateTimingDetails(data.timing_info, data.status, transcriptionInfo);
            }
            
            // Update detailed info text with dual progress
            let infoText = '';
            
            if (data.status === 'pending') {
                infoText = `File size: ${fileInfo.size_mb} MB\nPreparing for processing...`;
            } else if (data.status === 'chunking') {
                infoText = `📁 File: ${fileInfo.size_mb} MB\n`;
                infoText += `🔄 Creating chunks: ${chunksInfo.total}/${chunksInfo.estimated_total} chunks\n`;
                infoText += `📝 Transcribed: 0 chunks\n`;
                if (data.estimated_time_remaining) {
                    const minutes = Math.ceil(data.estimated_time_remaining / 60);
                    infoText += `⏱️ Est. remaining: ${minutes} minute${minutes > 1 ? 's' : ''}`;
                }
            } else if (data.status === 'transcription_starting') {
                infoText = `📁 File: ${fileInfo.size_mb} MB\n`;
                infoText += `✅ Chunks created: ${chunksInfo.total} chunks\n`;
                infoText += `🤖 Starting transcription...`;
            } else if (data.status === 'transcribing') {
                infoText = `📁 File: ${fileInfo.size_mb} MB\n`;
                infoText += `✅ Chunks created: ${chunksInfo.total}/${chunksInfo.estimated_total}\n`;
                infoText += `📝 Transcribed: ${transcriptionInfo.transcribed_chunks}/${chunksInfo.total} chunks\n`;
                infoText += `🔄 Active transcriptions: ${transcriptionInfo.active_transcriptions}\n`;
                if (data.estimated_time_remaining) {
                    const minutes = Math.ceil(data.estimated_time_remaining / 60);
                    infoText += `⏱️ Est. remaining: ${minutes} minute${minutes > 1 ? 's' : ''}`;
                }
            } else if (data.status === 'completed') {
                infoText = `📁 File: ${fileInfo.size_mb} MB\n`;
                infoText += `✅ Chunks created: ${chunksInfo.total}\n`;
                infoText += `✅ Transcribed: ${transcriptionInfo.transcribed_chunks} chunks\n`;
                infoText += `🎉 Processing complete!`;
                
                // Update transcript text immediately when completed
                if (transcriptionInfo.progressive_transcript) {
                    const transcriptTextarea = document.getElementById('transcript-text');
                    if (transcriptTextarea) {
                        transcriptTextarea.value = transcriptionInfo.progressive_transcript;
                        console.log(`Completion: Set transcript with ${transcriptionInfo.progressive_transcript.length} characters`);
                        
                        // Auto-scroll to show content
                        transcriptTextarea.scrollTop = transcriptTextarea.scrollHeight;
                        
                        // Update character count
                        const charCount = transcriptionInfo.progressive_transcript.length;
                        const wordCount = transcriptionInfo.progressive_transcript.split(/\s+/).length;
                        transcriptTextarea.setAttribute('data-word-count', `${wordCount} words, ${charCount} characters`);
                    }
                } else {
                    console.warn('Completion: No transcript text found in transcriptionInfo.progressive_transcript');
                    console.log('Completion: transcriptionInfo =', transcriptionInfo);
                }
                
                // Ensure transcript section is visible
                const transcriptSection = document.getElementById('transcript-section');
                if (transcriptSection) {
                    transcriptSection.style.display = 'block';
                }
                
                // Stop polling when complete
                console.log('Transcription completed, stopping progress polling');
                clearInterval(chunkingInterval);
                chunkingInterval = null;
                updateSidebarProgress('chunking', 100, false);
                updateSidebarStatus('Transcription complete!', 'success');
                updateWorkflowStep(2, 'completed');
                
                // Enable insights generation
                const generateButton = document.getElementById('generate-insights');
                if (generateButton) {
                    generateButton.disabled = false;
                    generateButton.focus();
                }
            }
            
            // Additional completion check for transcribed chunks
            if (chunksInfo.total > 0 && transcriptionInfo.transcribed_chunks >= chunksInfo.total && data.status !== 'completed') {
                console.log('All chunks transcribed, forcing completion status');
                // Force completion status
                clearInterval(chunkingInterval);
                chunkingInterval = null;
                updateSidebarProgress('chunking', 100, false);
                updateSidebarStatus('Transcription complete!', 'success');
                updateWorkflowStep(2, 'completed');
                
                const generateButton = document.getElementById('generate-insights');
                if (generateButton) {
                    generateButton.disabled = false;
                    generateButton.focus();
                }
            }
            
            document.getElementById('transcription-info').textContent = infoText;
            
            // Update progressive transcript if available
            if (transcriptionInfo.progressive_transcript) {
                // Debug logging
                console.log('Progressive update - transcriptionInfo:', transcriptionInfo);
                console.log('Progressive update - transcript length:', transcriptionInfo.progressive_transcript.length);
                
                // Ensure transcript section is visible before updating
                const transcriptSection = document.getElementById('transcript-section');
                if (transcriptSection && transcriptSection.style.display === 'none') {
                    transcriptSection.style.display = 'block';
                    console.log('Progressive update - made transcript section visible');
                }
                
                const transcriptTextarea = document.getElementById('transcript-text');
                console.log('Progressive update - transcript element exists:', !!transcriptTextarea);
                
                if (transcriptTextarea) {
                    transcriptTextarea.value = transcriptionInfo.progressive_transcript;
                    
                    // Auto-scroll to bottom to show latest content
                    transcriptTextarea.scrollTop = transcriptTextarea.scrollHeight;
                    
                    // Update character count or word count if element exists
                    const charCount = transcriptionInfo.progressive_transcript.length;
                    const wordCount = transcriptionInfo.progressive_transcript.split(/\s+/).length;
                    if (charCount > 0) {
                        // Show word count in placeholder when transcript has content
                        transcriptTextarea.setAttribute('data-word-count', `${wordCount} words, ${charCount} characters`);
                    }
                    
                    console.log(`Progressive update - Updated transcript: ${charCount} characters, ${wordCount} words`);
                } else {
                    console.error('Progressive update - transcript-text element not found in DOM!');
                }
            } else {
                // Debug: log when no transcript is available
                if (data.status === 'completed') {
                    console.warn('Transcription completed but no transcript text available');
                    console.log('Transcription info:', transcriptionInfo);
                } else if (data.status === 'processing' && transcriptionInfo.transcribed_chunks > 0) {
                    console.log('Progressive update - Processing but no transcript yet. Info:', transcriptionInfo);
                }
            }
        })
        .catch(error => {
            console.error('Progress polling error:', error);
            // Don't stop polling on transient errors, but show warning in console
        });
    }, 2000); // Poll every 2 seconds
}

// Poll progressive transcription progress for large files
function pollProgressiveTranscription() {
    if (!currentMeetingId) return;
    
    transcriptionInterval = setInterval(() => {
        fetch(`{% url "core:transcription_progress" %}?meeting_id=${currentMeetingId}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success === false) {
                throw new Error(data.error || 'Progressive transcription check failed');
            }
            
            // Update progressive transcript
            if (data.transcript) {
                const transcriptTextarea = document.getElementById('transcript-text');
                transcriptTextarea.value = data.transcript;
                // Auto-scroll to bottom to show latest content
                transcriptTextarea.scrollTop = transcriptTextarea.scrollHeight;
            }
            
            if (data.is_chunked && data.chunks_info) {
                const chunksInfo = data.chunks_info;
                const statusText = `Progressive transcription: ${chunksInfo.completed}/${chunksInfo.total} chunks completed`;
                updateSidebarStatus(statusText, 'processing');
                
                // Calculate overall progress
                const progress = chunksInfo.total > 0 ? Math.round((chunksInfo.completed / chunksInfo.total) * 100) : 0;
                updateSidebarProgress('transcription', progress, true);
                
                // Check if transcription is complete
                if (data.status === 'completed' || chunksInfo.completed === chunksInfo.total) {
                    clearInterval(transcriptionInterval);
                    transcriptionInterval = null;
                    
                    updateSidebarProgress('transcription', 100, false);
                    updateSidebarStatus('Progressive transcription completed!', 'success');
                    updateWorkflowStep(3, 'completed');
                    updateWorkflowStep(4, 'active');
                    
                    // Show generate insights button area
                    document.getElementById('transcript-section').style.display = 'block';
                    document.getElementById('retranscribe').style.display = 'inline-block';
                    showSidebarCancel(false);
                }
            } else {
                // Regular transcription progress
                updateSidebarProgress('transcription', data.progress || 0);
                if (data.status === 'completed') {
                    clearInterval(transcriptionInterval);
                    transcriptionInterval = null;
                    updateSidebarStatus('Transcription completed!', 'success');
                }
            }
        })
        .catch(error => {
            console.error('Progressive transcription progress error:', error);
            // Continue polling on errors
        });
    }, 3000); // Poll every 3 seconds for transcription
}

// Update progressive transcript display
function updateProgressiveTranscript() {
    if (!currentMeetingId) return;
    
    // Fetch current transcript state
    fetch(`{% url "core:transcription_progress" %}?meeting_id=${currentMeetingId}`)
    .then(response => response.json())
    .then(data => {
        if (data.success !== false && data.transcript) {
            const transcriptTextarea = document.getElementById('transcript-text');
            const currentText = transcriptTextarea.value;
            
            // Only update if text has changed to avoid cursor jumping
            if (currentText !== data.transcript) {
                const wasAtBottom = transcriptTextarea.scrollTop + transcriptTextarea.clientHeight >= transcriptTextarea.scrollHeight - 5;
                transcriptTextarea.value = data.transcript;
                
                // Maintain scroll position or auto-scroll if user was at bottom
                if (wasAtBottom) {
                    transcriptTextarea.scrollTop = transcriptTextarea.scrollHeight;
                }
            }
        }
    })
    .catch(error => {
        // Silently handle errors for progressive updates
        console.debug('Progressive transcript update error:', error);
    });
}

// Cancel transcription function
function cancelTranscription() {
    if (transcriptionInterval) {
        clearTimeout(transcriptionInterval);
        transcriptionInterval = null;
    }
    updateSidebarProgress('transcription', 0, false);
    updateSidebarStatus('Transcription cancelled', 'warning');
    showSidebarCancel(false);
}

// Generate insights with sidebar integration
document.getElementById('generate-insights').addEventListener('click', function() {
    if (!currentMeetingId) return;
    
    const transcriptText = document.getElementById('transcript-text').value.trim();
    if (!transcriptText) {
        updateSidebarStatus('Please provide a transcript before generating insights.', 'warning');
        return;
    }
    
    // Update sidebar status
    updateWorkflowStep(4, 'active');
    updateSidebarStatus('Starting AI analysis...', 'processing');
    updateSidebarProgress('insights', 0, true);
    
    fetch('{% url "core:generate_insights" %}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken()
        },
        body: JSON.stringify({
            meeting_id: currentMeetingId,
            transcript_text: transcriptText
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json().catch(error => {
            throw new Error('Invalid JSON response from server');
        });
    })
    .then(data => {
        if (data.success) {
            pollInsightsProgress();
        } else {
            throw new Error(data.error || 'Insights generation failed');
        }
    })
    .catch(error => {
        updateSidebarProgress('insights', 0, false);
        updateSidebarStatus(`Error: ${error.message}`, 'error');
    });
});

// Poll insights progress with sidebar integration
function pollInsightsProgress(retryCount = 0) {
    const maxRetries = 3;
    const baseDelay = 2000;
    const delay = Math.min(baseDelay * Math.pow(1.5, retryCount), 10000);
    
    insightsInterval = setTimeout(() => {
        fetch(`{% url "core:insights_progress" %}?meeting_id=${currentMeetingId}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json().catch(error => {
            throw new Error('Invalid JSON response from server');
        });
        })
        .then(data => {
            if (data.success === false) {
                throw new Error(data.error || 'Insights progress check failed');
            }
            updateSidebarProgress('insights', data.progress || 0);
            updateSidebarStatus(data.status || 'Analyzing...', 'processing');
            
            if (data.status === 'completed') {
                document.getElementById('situation-text').value = data.situation || '';
                document.getElementById('insights-text').value = data.insights || '';
                document.getElementById('insights-section').style.display = 'block';
                document.getElementById('regenerate-insights').style.display = 'inline-block';
                
                // Parse insights into categories
                parseInsightsIntoCategories(data.insights || '');
                
                // Update sidebar
                updateSidebarProgress('insights', 100, false);
                updateSidebarStatus('Analysis completed successfully!', 'success');
                updateWorkflowStep(4, 'completed');
                
                // Focus management
                setTimeout(() => {
                    document.getElementById('situation-text').focus();
                }, 500);
                
            } else if (data.status === 'failed') {
                updateSidebarProgress('insights', 0, false);
                updateSidebarStatus(`Analysis failed: ${data.error || 'Unknown error'}`, 'error');
                
            } else {
                pollInsightsProgress(0);
            }
        })
        .catch(error => {
            if (retryCount < maxRetries) {
                console.warn(`Insights polling attempt ${retryCount + 1} failed, retrying...`, error);
                pollInsightsProgress(retryCount + 1);
            } else {
                updateSidebarProgress('insights', 0, false);
                updateSidebarStatus('Connection error. Please check your internet connection.', 'error');
            }
        });
    }, delay);
}

// Removed - retry functionality now handled via sidebar status messages

// Save all data with improved UX
document.getElementById('save-all').addEventListener('click', function() {
    if (!currentMeetingId) return;
    
    const saveBtn = this;
    const originalText = saveBtn.innerHTML;
    saveBtn.disabled = true;
    saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Saving...';
    
    const data = {
        meeting_id: currentMeetingId,
        transcript_text: document.getElementById('transcript-text').value,
        situation: document.getElementById('situation-text').value,
        insights: document.getElementById('insights-text').value
    };
    
    fetch('{% url "core:save_analysis" %}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken()
        },
        body: JSON.stringify(data)
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json().catch(error => {
            throw new Error('Invalid JSON response from server');
        });
    })
    .then(data => {
        if (data.success) {
            SessionState.clear();
            saveBtn.innerHTML = '<i class="fas fa-check me-1"></i>Saved!';
            setTimeout(() => {
                window.location.href = '{% url "core:home" %}';
            }, 1000);
        } else {
            throw new Error(data.error || 'Save failed');
        }
    })
    .catch(error => {
        saveBtn.disabled = false;
        saveBtn.innerHTML = originalText;
        showError(`Save failed: ${error.message}`);
    });
});

// Additional utility functions
const resetUploadBtn = document.getElementById('reset-upload');
if (resetUploadBtn) {
    resetUploadBtn.addEventListener('click', function() {
        if (confirm('Are you sure you want to start over? All progress will be lost.')) {
            SessionState.clear();
            resetUIToFreshState();
            updateSidebarStatus('Ready to start new transcription', 'info');
        }
    });
}

const retranscribeBtn = document.getElementById('retranscribe');
if (retranscribeBtn) {
    retranscribeBtn.addEventListener('click', function() {
        if (confirm('Re-transcribe the audio? This will replace the current transcript.')) {
            const transcriptSection = document.getElementById('transcript-section');
            const insightsSection = document.getElementById('insights-section');
            const startTranscriptionBtn = document.getElementById('start-transcription');
            
            if (transcriptSection) transcriptSection.style.display = 'none';
            if (insightsSection) insightsSection.style.display = 'none';
            if (startTranscriptionBtn) startTranscriptionBtn.click();
        }
    });
}

const regenerateInsightsBtn = document.getElementById('regenerate-insights');
if (regenerateInsightsBtn) {
    regenerateInsightsBtn.addEventListener('click', function() {
        if (confirm('Regenerate insights? This will replace the current analysis.')) {
            const insightsSection = document.getElementById('insights-section');
            const generateInsightsBtn = document.getElementById('generate-insights');
            
            if (insightsSection) insightsSection.style.display = 'none';
            if (generateInsightsBtn) generateInsightsBtn.click();
        }
    });
}

const printAnalysisBtn = document.getElementById('print-analysis');
if (printAnalysisBtn) {
    printAnalysisBtn.addEventListener('click', function() {
        window.print();
    });
}

// Insights view toggle functionality
const insightsViewTextBtn = document.getElementById('insights-view-text');
if (insightsViewTextBtn) {
    insightsViewTextBtn.addEventListener('click', function() {
        const textView = document.getElementById('insights-text-view');
        const categoryView = document.getElementById('insights-category-view');
        const categoriesBtn = document.getElementById('insights-view-categories');
        
        if (textView) textView.style.display = 'block';
        if (categoryView) categoryView.style.display = 'none';
        this.classList.add('active');
        if (categoriesBtn) categoriesBtn.classList.remove('active');
    });
}

const insightsViewCategoriesBtn = document.getElementById('insights-view-categories');
if (insightsViewCategoriesBtn) {
    insightsViewCategoriesBtn.addEventListener('click', function() {
        const textView = document.getElementById('insights-text-view');
        const categoryView = document.getElementById('insights-category-view');
        const textBtn = document.getElementById('insights-view-text');
        
        if (textView) textView.style.display = 'none';
        if (categoryView) categoryView.style.display = 'block';
        this.classList.add('active');
        if (textBtn) textBtn.classList.remove('active');
    });
}

// Parse insights into categories
function parseInsightsIntoCategories(insightsText) {
    const categories = {
        'tasks': /\*\*Tasks & Action Items\*\*:(.*?)(?=\*\*|$)/s,
        'decisions': /\*\*Decisions Made\*\*:(.*?)(?=\*\*|$)/s,
        'qa': /\*\*Questions & Answers\*\*:(.*?)(?=\*\*|$)/s,
        'insights': /\*\*Key Insights\*\*:(.*?)(?=\*\*|$)/s,
        'deadlines': /\*\*Deadlines\*\*:(.*?)(?=\*\*|$)/s,
        'participants': /\*\*Meeting Participants\*\*:(.*?)(?=\*\*|$)/s,
        'followup': /\*\*Follow-up Actions\*\*:(.*?)(?=\*\*|$)/s,
        'risks': /\*\*Risks Identified\*\*:(.*?)(?=\*\*|$)/s,
        'agenda': /\*\*Meeting Agenda\*\*:(.*?)(?=\*\*|$)/s
    };

    for (const [key, regex] of Object.entries(categories)) {
        const match = insightsText.match(regex);
        const content = match ? match[1].trim() : 'No information available';
        const element = document.getElementById(`category-${key}`);
        if (element) {
            element.textContent = content || 'No information available';
        }
    }
}

// Initialize page
document.addEventListener('DOMContentLoaded', function() {
    // Load session state if available
    const savedState = SessionState.load();
    if (savedState && savedState.currentMeetingId) {
        console.log('Restored session:', savedState.currentMeetingId);
        updateSidebarStatus('Session restored', 'info');
    }
    
    // Auto-adjust model based on language selection
    const languageSelect = document.getElementById('language-select');
    if (languageSelect) {
        languageSelect.addEventListener('change', function() {
            const language = this.value;
            const modelSelect = document.getElementById('whisper-model');
            
            if (modelSelect && language === 'th') {
                // Recommend larger models for Thai
                if (modelSelect.value === 'tiny' || modelSelect.value === 'base') {
                    modelSelect.value = 'medium';
                    updateSidebarStatus('Model updated to Medium for Thai language', 'info');
                }
            }
            SessionState.save();
        });
    }
    
    // Handle model selection change - enable/disable upload
    const whisperModelSelect = document.getElementById('whisper-model');
    if (whisperModelSelect) {
        whisperModelSelect.addEventListener('change', function() {
            const selectedModel = this.value;
            const uploadArea = document.getElementById('upload-area');
            const audioFileInput = document.getElementById('audio-file');
            const uploadInstructions = document.getElementById('upload-instructions');
            
            if (selectedModel) {
                // Enable upload area
                uploadArea.classList.remove('disabled');
                uploadArea.setAttribute('tabindex', '0');
                uploadArea.setAttribute('aria-label', 'Upload audio file by clicking or drag and drop');
                audioFileInput.disabled = false;
                uploadInstructions.textContent = 'Drag & drop or click to browse';
                
                // Update workflow step
                updateWorkflowStep(1, 'completed');
                updateWorkflowStep(2, 'active');
                updateSidebarStatus(`Model selected: ${selectedModel}`, 'success');
            } else {
                // Disable upload area
                uploadArea.classList.add('disabled');
                uploadArea.setAttribute('tabindex', '-1');
                uploadArea.setAttribute('aria-label', 'Upload audio file - select a transcription model first');
                audioFileInput.disabled = true;
                uploadInstructions.textContent = 'Select a transcription model first';
                
                // Update workflow step
                updateWorkflowStep(1, 'active');
                updateWorkflowStep(2, 'pending');
                updateSidebarStatus('Select a transcription model to continue', 'info');
            }
            
            SessionState.save();
        });
    }

    // Provider selection handling
    const providerRadios = document.querySelectorAll('input[name="transcription_provider"]');
    const localConfig = document.getElementById('local-models-config');
    const apiConfig = document.getElementById('api-config');
    const apiProviderSelect = document.getElementById('api-provider');
    const apiModelSection = document.getElementById('api-model-section');
    const apiModelSelect = document.getElementById('api-model');
    const customEndpointSection = document.getElementById('custom-endpoint-section');
    const apiKeySection = document.getElementById('api-key-section');
    const apiProviderInfo = document.getElementById('api-provider-info');
    const providerInfoContent = document.getElementById('provider-info-content');

    // API provider model configurations
    const apiModels = {
        openai: [
            { value: 'whisper-1', text: 'Whisper-1 (Latest)' }
        ],
        assemblyai: [
            { value: 'best', text: 'Best (Highest accuracy)' },
            { value: 'nano', text: 'Nano (Fastest)' }
        ],
        deepgram: [
            { value: 'nova-2', text: 'Nova-2 (Latest)' },
            { value: 'nova', text: 'Nova (Standard)' },
            { value: 'enhanced', text: 'Enhanced (Legacy)' }
        ],
        custom: []
    };

    // API provider information
    const apiProviderInfos = {
        openai: {
            text: '💰 <strong>Pricing:</strong> $0.006 per minute<br>📏 <strong>File limit:</strong> 25MB per file<br>🌐 <strong>Languages:</strong> 99+ languages supported',
            class: 'alert-info'
        },
        assemblyai: {
            text: '💰 <strong>Pricing:</strong> ~$0.65 per hour<br>📏 <strong>File limit:</strong> 5GB per file<br>🎯 <strong>Features:</strong> Sentiment analysis, PII detection',
            class: 'alert-success'
        },
        deepgram: {
            text: '💰 <strong>Pricing:</strong> Competitive rates<br>🚀 <strong>Performance:</strong> Claims 40% more accurate, 5x faster<br>🏥 <strong>Specialized:</strong> Medical, finance, custom models',
            class: 'alert-primary'
        },
        custom: {
            text: '🔧 <strong>Custom Integration:</strong> Use your own API endpoint<br>🔒 <strong>Security:</strong> Full control over data and processing<br>⚙️ <strong>Requirements:</strong> Compatible API format required',
            class: 'alert-warning'
        }
    };

    // Provider selection change handler
    providerRadios.forEach(radio => {
        radio.addEventListener('change', function() {
            if (this.value === 'local') {
                localConfig.style.display = 'block';
                apiConfig.style.display = 'none';
                // Reset API form
                apiProviderSelect.value = '';
                apiModelSelect.innerHTML = '';
                apiModelSection.style.display = 'none';
                customEndpointSection.style.display = 'none';
                apiKeySection.style.display = 'none';
                apiProviderInfo.style.display = 'none';
            } else {
                localConfig.style.display = 'none';
                apiConfig.style.display = 'block';
                // Reset local form
                document.getElementById('whisper-model').value = '';
            }
            // Trigger model validation update
            validateModelSelection();
        });
    });

    // API provider selection handler
    if (apiProviderSelect) {
        apiProviderSelect.addEventListener('change', function() {
            const provider = this.value;
            
            // Show/hide sections based on provider
            if (provider) {
                if (provider === 'custom') {
                    customEndpointSection.style.display = 'block';
                    apiModelSection.style.display = 'none';
                } else {
                    customEndpointSection.style.display = 'none';
                    apiModelSection.style.display = 'block';
                    
                    // Populate models for this provider
                    apiModelSelect.innerHTML = '<option value="">Choose a model...</option>';
                    if (apiModels[provider]) {
                        apiModels[provider].forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.value;
                            option.textContent = model.text;
                            apiModelSelect.appendChild(option);
                        });
                    }
                }
                
                apiKeySection.style.display = 'block';
                
                // Show provider info
                if (apiProviderInfos[provider]) {
                    const info = apiProviderInfos[provider];
                    providerInfoContent.innerHTML = info.text;
                    apiProviderInfo.className = `alert ${info.class}`;
                    apiProviderInfo.style.display = 'block';
                }
            } else {
                apiModelSection.style.display = 'none';
                customEndpointSection.style.display = 'none';
                apiKeySection.style.display = 'none';
                apiProviderInfo.style.display = 'none';
            }
            
            // Trigger model validation update
            validateModelSelection();
        });
    }

    // API key show/hide toggle
    const showApiKeyLink = document.getElementById('show-api-key');
    const apiKeyInput = document.getElementById('api-key');
    if (showApiKeyLink && apiKeyInput) {
        showApiKeyLink.addEventListener('click', function(e) {
            e.preventDefault();
            if (apiKeyInput.type === 'password') {
                apiKeyInput.type = 'text';
                this.textContent = 'Hide';
            } else {
                apiKeyInput.type = 'password';
                this.textContent = 'Show';
            }
        });
    }

    // Enhanced model validation function
    function validateModelSelection() {
        const provider = document.querySelector('input[name="transcription_provider"]:checked').value;
        let isValid = false;
        
        if (provider === 'local') {
            const selectedModel = document.getElementById('whisper-model').value;
            isValid = selectedModel !== '';
        } else if (provider === 'api') {
            const apiProvider = apiProviderSelect.value;
            const apiKey = document.getElementById('api-key').value.trim();
            
            if (apiProvider === 'custom') {
                const customEndpoint = document.getElementById('custom-endpoint').value.trim();
                isValid = apiProvider !== '' && customEndpoint !== '' && apiKey !== '';
            } else if (apiProvider) {
                const apiModel = apiModelSelect.value;
                isValid = apiProvider !== '' && apiModel !== '' && apiKey !== '';
            }
        }
        
        // Update upload area based on validation
        const uploadArea = document.getElementById('upload-area');
        const audioFileInput = document.getElementById('audio-file');
        const uploadInstructions = document.getElementById('upload-instructions');
        
        if (isValid) {
            uploadArea.classList.remove('disabled');
            uploadArea.setAttribute('tabindex', '0');
            uploadArea.setAttribute('aria-label', 'Upload audio file');
            audioFileInput.disabled = false;
            uploadInstructions.textContent = 'Drag & drop or click to browse';
            
            // Update workflow step
            updateWorkflowStep(1, 'completed');
            updateWorkflowStep(2, 'active');
            updateSidebarStatus('Configuration complete - upload your audio file', 'success');
        } else {
            uploadArea.classList.add('disabled');
            uploadArea.setAttribute('tabindex', '-1');
            uploadArea.setAttribute('aria-label', 'Upload audio file - complete configuration first');
            audioFileInput.disabled = true;
            
            if (provider === 'local') {
                uploadInstructions.textContent = 'Select a transcription model first';
            } else {
                uploadInstructions.textContent = 'Complete API configuration first';
            }
            
            updateWorkflowStep(1, 'active');
            updateWorkflowStep(2, 'pending');
            updateSidebarStatus('Complete transcription configuration to continue', 'info');
        }
    }

    // Add validation triggers for API fields
    if (apiProviderSelect) apiProviderSelect.addEventListener('change', validateModelSelection);
    if (apiModelSelect) apiModelSelect.addEventListener('change', validateModelSelection);
    if (document.getElementById('custom-endpoint')) {
        document.getElementById('custom-endpoint').addEventListener('input', validateModelSelection);
    }
    if (document.getElementById('api-key')) {
        document.getElementById('api-key').addEventListener('input', validateModelSelection);
    }
    
    // Initialize workflow step
    updateWorkflowStep(1, 'active');
    
    // Mobile status panel toggle icon rotation
    const statusPanelCollapse = document.getElementById('status-panel-collapse');
    if (statusPanelCollapse) {
        statusPanelCollapse.addEventListener('show.bs.collapse', function () {
            const icon = document.getElementById('status-panel-icon');
            if (icon) {
                icon.classList.remove('fa-chevron-down');
                icon.classList.add('fa-chevron-up');
            }
        });
        
        statusPanelCollapse.addEventListener('hide.bs.collapse', function () {
            const icon = document.getElementById('status-panel-icon');
            if (icon) {
                icon.classList.remove('fa-chevron-up');
                icon.classList.add('fa-chevron-down');
            }
        });
    }
});

// Smart session management for page loads
document.addEventListener('DOMContentLoaded', function() {
    // Check if there's a restored session with a meeting
    if (currentMeetingId) {
        fetch(`{% url "core:chunking_progress" %}?meeting_id=${currentMeetingId}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const isCompleted = data.status === 'completed';
                const isInProgress = ['chunking', 'transcribing', 'processing'].includes(data.status);
                
                if (isInProgress) {
                    // Active workflow - restore the UI state
                    console.log('Page load: Active workflow detected, restoring UI state');
                    const transcriptSection = document.getElementById('transcript-section');
                    if (transcriptSection) {
                        transcriptSection.style.display = 'block';
                    }
                    
                    // Resume polling for active workflows
                    if (data.status !== 'completed') {
                        pollChunkingProgress();
                    }
                } else if (isCompleted) {
                    // Completed workflow - check age and ask user if they want to continue
                    console.log('Page load: Found completed transcription from previous session');
                    
                    // Get session age
                    const saved = localStorage.getItem('tm_intellimind_session');
                    const sessionAge = saved ? Date.now() - JSON.parse(saved).timestamp : 0;
                    const isRecent = sessionAge < 600000; // 10 minutes
                    
                    let shouldRestore = false;
                    
                    // Always ask user for permission, regardless of age
                    shouldRestore = confirm(
                        'You have a completed transcription from a previous session. Would you like to continue with it?\\n\\n' +
                        'Click OK to restore the transcript, or Cancel to start fresh.'
                    );
                    console.log(`Page load: User chose ${shouldRestore ? 'restore' : 'fresh start'}`);
                    
                    if (shouldRestore) {
                        // User wants to restore - show the completed transcript
                        const transcriptSection = document.getElementById('transcript-section');
                        if (transcriptSection) {
                            transcriptSection.style.display = 'block';
                        }
                        
                        const transcriptionInfo = data.transcription_info || {};
                        if (transcriptionInfo.progressive_transcript) {
                            const transcriptTextarea = document.getElementById('transcript-text');
                            if (transcriptTextarea) {
                                transcriptTextarea.value = transcriptionInfo.progressive_transcript;
                                console.log('Page load: Restored transcript text by user choice');
                            }
                        }
                        
                        // Enable Generate Insights button
                        const generateButton = document.getElementById('generate-insights');
                        if (generateButton) {
                            generateButton.disabled = false;
                        }
                        
                        updateSidebarStatus('Previous session restored', 'success');
                        
                        // Show reset button for easy fresh start
                        const resetButton = document.getElementById('reset-upload');
                        if (resetButton) {
                            resetButton.style.display = 'inline-block';
                        }
                    } else {
                        // User wants fresh start - clear session and reset UI
                        console.log('Page load: User chose to start fresh, clearing session');
                        SessionState.clear();
                        
                        // Reset UI to fresh state
                        resetUIToFreshState();
                        updateSidebarStatus('Ready to start new transcription', 'info');
                    }
                } else {
                    // Unknown/failed state - clear session and reset UI
                    console.log('Page load: Unknown session state, clearing');
                    SessionState.clear();
                    resetUIToFreshState();
                }
            }
        })
        .catch(error => {
            console.debug('Page load check failed, clearing session:', error);
            SessionState.clear();
            resetUIToFreshState();
        });
    }
});

// Cleanup on page unload and visibility change
window.addEventListener('beforeunload', function() {
    if (transcriptionInterval) clearTimeout(transcriptionInterval);
    if (insightsInterval) clearTimeout(insightsInterval);
    if (chunkingInterval) clearInterval(chunkingInterval);
});

// Stop polling when tab becomes hidden to reduce server load
document.addEventListener('visibilitychange', function() {
    if (document.hidden && chunkingInterval) {
        console.log('Tab hidden: stopping polling to reduce server load');
        clearInterval(chunkingInterval);
        chunkingInterval = null;
    }
});
</script>
{% endblock %}